import math
import random

# ------------------------------------------------------------
# 1. Define the Problem: Create cities with coordinates
# ------------------------------------------------------------
def euclidean_distance(city1, city2):
    """Compute Euclidean distance between two cities."""
    return math.sqrt((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2)

def create_distance_matrix(cities):
    """Generate a distance matrix for all cities."""
    num_cities = len(cities)
    dist_matrix = [[0 for _ in range(num_cities)] for _ in range(num_cities)]
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                dist_matrix[i][j] = euclidean_distance(cities[i], cities[j])
    return dist_matrix

# ------------------------------------------------------------
# 2. Initialize Parameters
# ------------------------------------------------------------
NUM_ANTS = 20              # Number of ants
ALPHA = 1.0                # Pheromone importance
BETA = 5.0                 # Heuristic importance (distance influence)
RHO = 0.5                  # Pheromone evaporation rate
Q = 100                    # Pheromone deposit factor
NUM_ITERATIONS = 100       # Number of iterations

# ------------------------------------------------------------
# 3. Construct Solutions
# ------------------------------------------------------------
def select_next_city(ant, pheromone, distances, alpha, beta):
    current_city = ant[-1]
    num_cities = len(distances)
    probabilities = [0] * num_cities
    total = 0

    # Calculate probabilities for unvisited cities
    for city in range(num_cities):
        if city not in ant:
            pheromone_val = pheromone[current_city][city] ** alpha
            heuristic_val = (1 / (distances[current_city][city] + 1e-10)) ** beta
            probabilities[city] = pheromone_val * heuristic_val
            total += probabilities[city]

    # Normalize probabilities
    if total == 0:
        return random.choice([c for c in range(num_cities) if c not in ant])

    probabilities = [p / total for p in probabilities]

    # Roulette wheel selection
    r = random.random()
    cumulative = 0
    for city, prob in enumerate(probabilities):
        cumulative += prob
        if r <= cumulative:
            return city

    # Fallback (in case of rounding)
    return random.choice([c for c in range(num_cities) if c not in ant])

def construct_solutions(pheromone, distances):
    """Construct tours for all ants."""
    num_cities = len(distances)
    ants = []

    for _ in range(NUM_ANTS):
        start_city = random.randint(0, num_cities - 1)
        ant = [start_city]

        while len(ant) < num_cities:
            next_city = select_next_city(ant, pheromone, distances, ALPHA, BETA)
            ant.append(next_city)
        ants.append(ant)
    return ants

# ------------------------------------------------------------
# 4. Update Pheromones
# ------------------------------------------------------------
def calculate_tour_length(tour, distances):
    length = 0
    for i in range(len(tour)):
        length += distances[tour[i]][tour[(i + 1) % len(tour)]]
    return length

def update_pheromones(pheromone, ants, distances):
    num_cities = len(distances)

    # Evaporate pheromones
    for i in range(num_cities):
        for j in range(num_cities):
            pheromone[i][j] *= (1 - RHO)
            if pheromone[i][j] < 1e-10:
                pheromone[i][j] = 1e-10

    # Add pheromones based on ant tours
    for ant in ants:
        tour_length = calculate_tour_length(ant, distances)
        deposit = Q / tour_length
        for i in range(len(ant)):
            a = ant[i]
            b = ant[(i + 1) % len(ant)]
            pheromone[a][b] += deposit
            pheromone[b][a] += deposit  # symmetric update for undirected graph

# ------------------------------------------------------------
# 5. Iterate and Track Best Solution
# ------------------------------------------------------------
def ant_colony_optimization(cities):
    distances = create_distance_matrix(cities)
    num_cities = len(cities)
    pheromone = [[1 for _ in range(num_cities)] for _ in range(num_cities)]

    best_tour = None
    best_length = float("inf")

    for iteration in range(NUM_ITERATIONS):
        ants = construct_solutions(pheromone, distances)
        update_pheromones(pheromone, ants, distances)

        for ant in ants:
            length = calculate_tour_length(ant, distances)
            if length < best_length:
                best_length = length
                best_tour = ant[:]

        if iteration % 10 == 0 or iteration == NUM_ITERATIONS - 1:
            print(f"Iteration {iteration + 1}/{NUM_ITERATIONS} | Best Length: {best_length:.4f}")

    return best_tour, best_length

# ------------------------------------------------------------
# 6. Run the Algorithm and Output the Best Solution
# ------------------------------------------------------------
if __name__ == "__main__":
    # Example: 10 random cities
    cities = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(10)]

    best_tour, best_length = ant_colony_optimization(cities)

    print("\nBest Tour Found:")
    print(best_tour)
    print(f"Best Tour Length: {best_length:.4f}")
